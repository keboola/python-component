<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>keboola.component.base API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>keboola.component.base</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import contextlib
import json
import logging
import os
import sys
from abc import ABC
from abc import abstractmethod
from functools import wraps
from pathlib import Path
from typing import Dict
from typing import Union, List, Optional

from . import dao
from . import table_schema as ts
from .interface import CommonInterface
from .sync_actions import SyncActionResult, process_sync_action_result

KEY_DEBUG = &#39;debug&#39;

# Mapping of sync actions &#34;action name&#34;:&#34;method_name&#34;
_SYNC_ACTION_MAPPING = {&#34;run&#34;: &#34;run&#34;}


def sync_action(action_name: str):
    &#34;&#34;&#34;

       Decorator for marking sync actions method.
       For more info see [Sync actions](https://developers.keboola.com/extend/common-interface/actions/).

        Usage:

    ```
    import csv
    import logging

    from keboola.component.base import ComponentBase, sync_action

    class Component(ComponentBase):

        def run(self):
            &#39;&#39;&#39;
            Main execution code
            &#39;&#39;&#39;
            pass

        # sync action that is executed when configuration.json &#34;action&#34;:&#34;testConnection&#34; parameter is present.
        @sync_action(&#39;testConnection&#39;)
        def test_connection(self):
            connection = self.configuration.parameters.get(&#39;test_connection&#39;)
            if connection == &#34;fail&#34;:
                raise UserException(&#34;failed&#34;)
            elif connection == &#34;succeed&#34;:
                # this is ignored when run as sync action.
                logging.info(&#34;succeed&#34;)


    if __name__ == &#34;__main__&#34;:
        try:
            comp = Component()
            # this triggers the run method by default and is controlled by the configuration.action parameter
            comp.execute_action()
        except UserException as exc:
            logging.exception(exc)
            exit(1)
        except Exception as exc:
            logging.exception(exc)
            exit(2)
    ```

    Args:
        action_name: Name of the action registered in Developer Portal

    Returns:

    &#34;&#34;&#34;

    def decorate(func):
        # to allow pythonic names / action name mapping
        if action_name == &#39;run&#39;:
            raise ValueError(&#39;Sync action name &#34;run&#34; is reserved base action! Use different name.&#39;)
        _SYNC_ACTION_MAPPING[action_name] = func.__name__

        @wraps(func)
        def action_wrapper(self, *args, **kwargs):
            # override when run as sync action, because it could be also called normally within run
            is_sync_action = self.configuration.action != &#39;run&#39;

            # do operations with func
            if is_sync_action:
                stdout_redirect = None
                # mute logging just in case
                logging.getLogger().setLevel(logging.FATAL)
            else:
                stdout_redirect = sys.stdout

            try:
                # when success, only supported syntax can be in output / log, so redirect stdout before.
                with contextlib.redirect_stdout(stdout_redirect):
                    result: Union[None, SyncActionResult, List[SyncActionResult]] = func(self, *args, **kwargs)

                if is_sync_action:
                    # sync action expects valid JSON in stdout on success.
                    result_str = process_sync_action_result(result)
                    sys.stdout.write(result_str)

                return result

            except Exception as e:
                if is_sync_action:
                    # sync actions expect stderr
                    sys.stderr.write(str(e))
                    exit(1)
                else:
                    raise e

        return action_wrapper

    return decorate


class ComponentBase(ABC, CommonInterface):
    def __init__(self, data_path_override: Optional[str] = None,
                 schema_path_override: Optional[str] = None,
                 required_parameters: Optional[list] = None,
                 required_image_parameters: Optional[list] = None):
        &#34;&#34;&#34;
        Base class for general Python components. Initializes the CommonInterface
        and performs configuration validation.

        For easier debugging the data folder is picked up by default from `../data` path,
        relative to working directory.

        If `debug` parameter is present in the `config.json`, the default logger is set to verbose DEBUG mode.

        It executes [Sync actions](https://developers.keboola.com/extend/common-interface/actions/)
        when &#34;action&#34; is defined in the configuration.json based on the @action_decorator.

        Args:
            data_path_override:
                optional path to data folder that overrides the default behaviour (`KBC_DATADIR` environment variable).
                May be also specified by &#39;-d&#39; or &#39;--data&#39; commandline argument
            required_parameters:
                Optional[dict]: DEPRECATED required configuration parameters, if filled in,
                validation is done at constructor level
            required_image_parameters:
                Optional[dict]: DEPRECATED required image parameters, if filled in,
                validation is done at constructor level
        Raises:
            UserException - on config validation errors.
        &#34;&#34;&#34;

        # for easier local project setup
        super().__init__(data_folder_path=self._get_data_folder_override_path(data_path_override))

        if required_parameters:
            self.validate_configuration_parameters(required_parameters)
        if required_image_parameters:
            self.validate_image_parameters(required_image_parameters)

        if self.configuration.parameters.get(KEY_DEBUG):
            self.set_debug_mode()

        self.schema_folder_path = self._get_schema_folder_path(schema_path_override)

    @staticmethod
    def _get_default_data_path() -&gt; str:
        &#34;&#34;&#34;
        Returns default data_path, by default `../data` is used, relative to working directory.
        This helps with local development.

        Returns:

        &#34;&#34;&#34;
        return Path(os.getcwd()).resolve().parent.joinpath(&#39;data&#39;).as_posix()

    def _get_data_folder_override_path(self, data_path_override: str = None) -&gt; str:
        &#34;&#34;&#34;
        Returns overridden value of the data_folder_path in case the data_path_override variable
        or `KBC_DATADIR` environment variable is defined. The `data_path_override` variable takes precendence.

        Returns null if override is not in place.

        Args:
            data_path_override:

        Returns:

        &#34;&#34;&#34;
        data_folder_path = None
        if data_path_override:
            data_folder_path = data_path_override
        elif not os.environ.get(&#39;KBC_DATADIR&#39;):
            data_folder_path = self._get_default_data_path()
        return data_folder_path

    def _get_schema_folder_path(self, schema_path_override: str = None) -&gt; str:
        &#34;&#34;&#34;
            Returns value of the schema_folder_path in case the schema_path_override variable is provided or
            the default schema_folder_path is found.

        &#34;&#34;&#34;
        return schema_path_override or self._get_default_schema_folder_path()

    @staticmethod
    def _get_default_schema_folder_path() -&gt; Optional[str]:
        &#34;&#34;&#34;
             Finds the default schema_folder_path if it exists.

        &#34;&#34;&#34;
        container_schema_dir = Path(&#34;./src/schemas/&#34;).absolute().as_posix()
        local_schema_dir = Path(&#34;./schemas&#34;).absolute().as_posix()
        if os.path.isdir(container_schema_dir):
            return container_schema_dir
        elif os.path.isdir(local_schema_dir):
            return local_schema_dir

    @staticmethod
    def set_debug_mode():
        &#34;&#34;&#34;
        Set the default logger to verbose mode.
        Returns:

        &#34;&#34;&#34;
        logging.getLogger().setLevel(logging.DEBUG)

    @abstractmethod
    def run(self):
        &#34;&#34;&#34;
        Main execution code of default run action.


        &#34;&#34;&#34;
        pass

    def execute_action(self):
        &#34;&#34;&#34;
        Executes action defined in the configuration.
        The default action is &#39;run&#39;. See base._SYNC_ACTION_MAPPING
        &#34;&#34;&#34;
        action = self.configuration.action
        if not action:
            logging.warning(&#34;No action defined in the configuration, using the default run action.&#34;)
            action = &#39;run&#39;

        try:
            action = _SYNC_ACTION_MAPPING[action]
            action_method = getattr(self, action)
        except (AttributeError, KeyError) as e:
            raise AttributeError(f&#34;The defined action {action} is not implemented!&#34;) from e
        return action_method()

    def create_out_table_definition_from_schema(self, table_schema: ts.TableSchema, is_sliced: bool = False,
                                                destination: str = &#39;&#39;, incremental: bool = None,
                                                enclosure: str = &#39;&#34;&#39;, delimiter: str = &#39;,&#39;,
                                                delete_where: dict = None) -&gt; dao.TableDefinition:
        &#34;&#34;&#34;
            Creates an out table definition using a defined table schema.
            This method uses the given table schema and generates metadata of the table. Along with the additional
            key word arguments it creates an out table definition.

            Args:
                table_schema : table of the schema for which a table definition will be created
                is_sliced: True if the full_path points to a folder with sliced tables
                destination: String name of the table in Storage.
                incremental: Set to true to enable incremental loading
                enclosure: str: CSV enclosure, by default &#34;
                delimiter: str: CSV delimiter, by default ,
                delete_where: Dict with settings for deleting rows

            Returns:
                TableDefinition object initialized with all table metadata defined in a schema

        &#34;&#34;&#34;
        table_metadata = self._generate_table_metadata(table_schema)
        return self.create_out_table_definition(name=table_schema.csv_name,
                                                columns=table_schema.field_names,
                                                primary_key=table_schema.primary_keys,
                                                table_metadata=table_metadata,
                                                is_sliced=is_sliced,
                                                destination=destination,
                                                incremental=incremental,
                                                enclosure=enclosure,
                                                delimiter=delimiter,
                                                delete_where=delete_where)

    def get_table_schema_by_name(self, schema_name: str,
                                 schema_folder_path: Optional[str] = None) -&gt; ts.TableSchema:
        &#34;&#34;&#34;
            The method finds a table schema JSON based on it&#39;s name in a defined schema_folder_path and generates
            a TableSchema object.

            Args:
                schema_name : name of the schema in the schema_folder_path. e.g. for schema in &#39;src/schemas/order.json&#39;
                              schema_name is &#39;order&#39;
                schema_folder_path : directory path to the schema folder, by default the schema folder is set at
                                     &#39;src/schemas&#39;
            Returns:
                TableSchema object initialized with all available table metadata


        &#34;&#34;&#34;
        if not schema_folder_path:
            schema_folder_path = self.schema_folder_path
        self._validate_schema_folder_path(schema_folder_path)
        schema_dict = self._load_table_schema_dict(schema_name, schema_folder_path)
        return ts.init_table_schema_from_dict(schema_dict)

    @staticmethod
    def _load_table_schema_dict(schema_name: str, schema_folder_path: str) -&gt; Dict:
        try:
            with open(os.path.join(schema_folder_path, f&#34;{schema_name}.json&#34;), &#39;r&#39;) as schema_file:
                json_schema = json.loads(schema_file.read())
        except FileNotFoundError as file_err:
            raise FileNotFoundError(
                f&#34;Schema for corresponding schema name : {schema_name} is not found in the schema directory. &#34;
                f&#34;Make sure that &#39;{schema_name}&#39;.json &#34;
                f&#34;exists in the directory &#39;{schema_folder_path}&#39;&#34;) from file_err
        return json_schema

    @staticmethod
    def _validate_schema_folder_path(schema_folder_path: str):
        if not schema_folder_path or not os.path.isdir(schema_folder_path):
            raise FileNotFoundError(&#34;A schema folder path must be defined in order to create a out table definition &#34;
                                    &#34;from a schema. If a schema folder path is not defined, the schemas folder must be&#34;
                                    &#34; located in the &#39;src&#39; directory of a component : src/schemas&#34;)

    def _generate_table_metadata(self, table_schema: ts.TableSchema) -&gt; dao.TableMetadata:
        &#34;&#34;&#34;
            Generates a TableMetadata object for the table definition using a TableSchema object.

        &#34;&#34;&#34;
        table_metadata = dao.TableMetadata()
        if table_schema.description:
            table_metadata.add_table_description(table_schema.description)
        table_metadata.add_column_descriptions({field.name: field.description for field in table_schema.fields})
        table_metadata = self._add_field_data_types_to_table_metadata(table_schema, table_metadata)
        return table_metadata

    @staticmethod
    def _add_field_data_types_to_table_metadata(table_schema: ts.TableSchema,
                                                table_metadata: dao.TableMetadata) -&gt; dao.TableMetadata:
        &#34;&#34;&#34;
            Adds data types of all fields specified in a TableSchema object to a given TableMetadata object

        &#34;&#34;&#34;
        for field in table_schema.fields:
            if field.base_type:
                table_metadata.add_column_data_type(field.name,
                                                    data_type=field.base_type,
                                                    nullable=field.nullable,
                                                    length=field.length,
                                                    default=field.default)
        return table_metadata</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="keboola.component.base.sync_action"><code class="name flex">
<span>def <span class="ident">sync_action</span></span>(<span>action_name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Decorator for marking sync actions method.
For more info see <a href="https://developers.keboola.com/extend/common-interface/actions/">Sync actions</a>.</p>
<pre><code>Usage:
</code></pre>
<pre><code>import csv
import logging

from keboola.component.base import ComponentBase, sync_action

class Component(ComponentBase):

    def run(self):
        '''
        Main execution code
        '''
        pass

    # sync action that is executed when configuration.json &quot;action&quot;:&quot;testConnection&quot; parameter is present.
    @sync_action('testConnection')
    def test_connection(self):
        connection = self.configuration.parameters.get('test_connection')
        if connection == &quot;fail&quot;:
            raise UserException(&quot;failed&quot;)
        elif connection == &quot;succeed&quot;:
            # this is ignored when run as sync action.
            logging.info(&quot;succeed&quot;)


if __name__ == &quot;__main__&quot;:
    try:
        comp = Component()
        # this triggers the run method by default and is controlled by the configuration.action parameter
        comp.execute_action()
    except UserException as exc:
        logging.exception(exc)
        exit(1)
    except Exception as exc:
        logging.exception(exc)
        exit(2)
</code></pre>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>action_name</code></strong></dt>
<dd>Name of the action registered in Developer Portal</dd>
</dl>
<p>Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def sync_action(action_name: str):
    &#34;&#34;&#34;

       Decorator for marking sync actions method.
       For more info see [Sync actions](https://developers.keboola.com/extend/common-interface/actions/).

        Usage:

    ```
    import csv
    import logging

    from keboola.component.base import ComponentBase, sync_action

    class Component(ComponentBase):

        def run(self):
            &#39;&#39;&#39;
            Main execution code
            &#39;&#39;&#39;
            pass

        # sync action that is executed when configuration.json &#34;action&#34;:&#34;testConnection&#34; parameter is present.
        @sync_action(&#39;testConnection&#39;)
        def test_connection(self):
            connection = self.configuration.parameters.get(&#39;test_connection&#39;)
            if connection == &#34;fail&#34;:
                raise UserException(&#34;failed&#34;)
            elif connection == &#34;succeed&#34;:
                # this is ignored when run as sync action.
                logging.info(&#34;succeed&#34;)


    if __name__ == &#34;__main__&#34;:
        try:
            comp = Component()
            # this triggers the run method by default and is controlled by the configuration.action parameter
            comp.execute_action()
        except UserException as exc:
            logging.exception(exc)
            exit(1)
        except Exception as exc:
            logging.exception(exc)
            exit(2)
    ```

    Args:
        action_name: Name of the action registered in Developer Portal

    Returns:

    &#34;&#34;&#34;

    def decorate(func):
        # to allow pythonic names / action name mapping
        if action_name == &#39;run&#39;:
            raise ValueError(&#39;Sync action name &#34;run&#34; is reserved base action! Use different name.&#39;)
        _SYNC_ACTION_MAPPING[action_name] = func.__name__

        @wraps(func)
        def action_wrapper(self, *args, **kwargs):
            # override when run as sync action, because it could be also called normally within run
            is_sync_action = self.configuration.action != &#39;run&#39;

            # do operations with func
            if is_sync_action:
                stdout_redirect = None
                # mute logging just in case
                logging.getLogger().setLevel(logging.FATAL)
            else:
                stdout_redirect = sys.stdout

            try:
                # when success, only supported syntax can be in output / log, so redirect stdout before.
                with contextlib.redirect_stdout(stdout_redirect):
                    result: Union[None, SyncActionResult, List[SyncActionResult]] = func(self, *args, **kwargs)

                if is_sync_action:
                    # sync action expects valid JSON in stdout on success.
                    result_str = process_sync_action_result(result)
                    sys.stdout.write(result_str)

                return result

            except Exception as e:
                if is_sync_action:
                    # sync actions expect stderr
                    sys.stderr.write(str(e))
                    exit(1)
                else:
                    raise e

        return action_wrapper

    return decorate</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="keboola.component.base.ComponentBase"><code class="flex name class">
<span>class <span class="ident">ComponentBase</span></span>
<span>(</span><span>data_path_override: Optional[str] = None, schema_path_override: Optional[str] = None, required_parameters: Optional[list] = None, required_image_parameters: Optional[list] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>Base class for general Python components. Initializes the CommonInterface
and performs configuration validation.</p>
<p>For easier debugging the data folder is picked up by default from <code>../data</code> path,
relative to working directory.</p>
<p>If <code>debug</code> parameter is present in the <code>config.json</code>, the default logger is set to verbose DEBUG mode.</p>
<p>It executes <a href="https://developers.keboola.com/extend/common-interface/actions/">Sync actions</a>
when "action" is defined in the configuration.json based on the @action_decorator.</p>
<h2 id="args">Args</h2>
<p>data_path_override:
optional path to data folder that overrides the default behaviour (<code>KBC_DATADIR</code> environment variable).
May be also specified by '-d' or '&ndash;data' commandline argument
required_parameters:
Optional[dict]: DEPRECATED required configuration parameters, if filled in,
validation is done at constructor level
required_image_parameters:
Optional[dict]: DEPRECATED required image parameters, if filled in,
validation is done at constructor level</p>
<h2 id="raises">Raises</h2>
<p>UserException - on config validation errors.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ComponentBase(ABC, CommonInterface):
    def __init__(self, data_path_override: Optional[str] = None,
                 schema_path_override: Optional[str] = None,
                 required_parameters: Optional[list] = None,
                 required_image_parameters: Optional[list] = None):
        &#34;&#34;&#34;
        Base class for general Python components. Initializes the CommonInterface
        and performs configuration validation.

        For easier debugging the data folder is picked up by default from `../data` path,
        relative to working directory.

        If `debug` parameter is present in the `config.json`, the default logger is set to verbose DEBUG mode.

        It executes [Sync actions](https://developers.keboola.com/extend/common-interface/actions/)
        when &#34;action&#34; is defined in the configuration.json based on the @action_decorator.

        Args:
            data_path_override:
                optional path to data folder that overrides the default behaviour (`KBC_DATADIR` environment variable).
                May be also specified by &#39;-d&#39; or &#39;--data&#39; commandline argument
            required_parameters:
                Optional[dict]: DEPRECATED required configuration parameters, if filled in,
                validation is done at constructor level
            required_image_parameters:
                Optional[dict]: DEPRECATED required image parameters, if filled in,
                validation is done at constructor level
        Raises:
            UserException - on config validation errors.
        &#34;&#34;&#34;

        # for easier local project setup
        super().__init__(data_folder_path=self._get_data_folder_override_path(data_path_override))

        if required_parameters:
            self.validate_configuration_parameters(required_parameters)
        if required_image_parameters:
            self.validate_image_parameters(required_image_parameters)

        if self.configuration.parameters.get(KEY_DEBUG):
            self.set_debug_mode()

        self.schema_folder_path = self._get_schema_folder_path(schema_path_override)

    @staticmethod
    def _get_default_data_path() -&gt; str:
        &#34;&#34;&#34;
        Returns default data_path, by default `../data` is used, relative to working directory.
        This helps with local development.

        Returns:

        &#34;&#34;&#34;
        return Path(os.getcwd()).resolve().parent.joinpath(&#39;data&#39;).as_posix()

    def _get_data_folder_override_path(self, data_path_override: str = None) -&gt; str:
        &#34;&#34;&#34;
        Returns overridden value of the data_folder_path in case the data_path_override variable
        or `KBC_DATADIR` environment variable is defined. The `data_path_override` variable takes precendence.

        Returns null if override is not in place.

        Args:
            data_path_override:

        Returns:

        &#34;&#34;&#34;
        data_folder_path = None
        if data_path_override:
            data_folder_path = data_path_override
        elif not os.environ.get(&#39;KBC_DATADIR&#39;):
            data_folder_path = self._get_default_data_path()
        return data_folder_path

    def _get_schema_folder_path(self, schema_path_override: str = None) -&gt; str:
        &#34;&#34;&#34;
            Returns value of the schema_folder_path in case the schema_path_override variable is provided or
            the default schema_folder_path is found.

        &#34;&#34;&#34;
        return schema_path_override or self._get_default_schema_folder_path()

    @staticmethod
    def _get_default_schema_folder_path() -&gt; Optional[str]:
        &#34;&#34;&#34;
             Finds the default schema_folder_path if it exists.

        &#34;&#34;&#34;
        container_schema_dir = Path(&#34;./src/schemas/&#34;).absolute().as_posix()
        local_schema_dir = Path(&#34;./schemas&#34;).absolute().as_posix()
        if os.path.isdir(container_schema_dir):
            return container_schema_dir
        elif os.path.isdir(local_schema_dir):
            return local_schema_dir

    @staticmethod
    def set_debug_mode():
        &#34;&#34;&#34;
        Set the default logger to verbose mode.
        Returns:

        &#34;&#34;&#34;
        logging.getLogger().setLevel(logging.DEBUG)

    @abstractmethod
    def run(self):
        &#34;&#34;&#34;
        Main execution code of default run action.


        &#34;&#34;&#34;
        pass

    def execute_action(self):
        &#34;&#34;&#34;
        Executes action defined in the configuration.
        The default action is &#39;run&#39;. See base._SYNC_ACTION_MAPPING
        &#34;&#34;&#34;
        action = self.configuration.action
        if not action:
            logging.warning(&#34;No action defined in the configuration, using the default run action.&#34;)
            action = &#39;run&#39;

        try:
            action = _SYNC_ACTION_MAPPING[action]
            action_method = getattr(self, action)
        except (AttributeError, KeyError) as e:
            raise AttributeError(f&#34;The defined action {action} is not implemented!&#34;) from e
        return action_method()

    def create_out_table_definition_from_schema(self, table_schema: ts.TableSchema, is_sliced: bool = False,
                                                destination: str = &#39;&#39;, incremental: bool = None,
                                                enclosure: str = &#39;&#34;&#39;, delimiter: str = &#39;,&#39;,
                                                delete_where: dict = None) -&gt; dao.TableDefinition:
        &#34;&#34;&#34;
            Creates an out table definition using a defined table schema.
            This method uses the given table schema and generates metadata of the table. Along with the additional
            key word arguments it creates an out table definition.

            Args:
                table_schema : table of the schema for which a table definition will be created
                is_sliced: True if the full_path points to a folder with sliced tables
                destination: String name of the table in Storage.
                incremental: Set to true to enable incremental loading
                enclosure: str: CSV enclosure, by default &#34;
                delimiter: str: CSV delimiter, by default ,
                delete_where: Dict with settings for deleting rows

            Returns:
                TableDefinition object initialized with all table metadata defined in a schema

        &#34;&#34;&#34;
        table_metadata = self._generate_table_metadata(table_schema)
        return self.create_out_table_definition(name=table_schema.csv_name,
                                                columns=table_schema.field_names,
                                                primary_key=table_schema.primary_keys,
                                                table_metadata=table_metadata,
                                                is_sliced=is_sliced,
                                                destination=destination,
                                                incremental=incremental,
                                                enclosure=enclosure,
                                                delimiter=delimiter,
                                                delete_where=delete_where)

    def get_table_schema_by_name(self, schema_name: str,
                                 schema_folder_path: Optional[str] = None) -&gt; ts.TableSchema:
        &#34;&#34;&#34;
            The method finds a table schema JSON based on it&#39;s name in a defined schema_folder_path and generates
            a TableSchema object.

            Args:
                schema_name : name of the schema in the schema_folder_path. e.g. for schema in &#39;src/schemas/order.json&#39;
                              schema_name is &#39;order&#39;
                schema_folder_path : directory path to the schema folder, by default the schema folder is set at
                                     &#39;src/schemas&#39;
            Returns:
                TableSchema object initialized with all available table metadata


        &#34;&#34;&#34;
        if not schema_folder_path:
            schema_folder_path = self.schema_folder_path
        self._validate_schema_folder_path(schema_folder_path)
        schema_dict = self._load_table_schema_dict(schema_name, schema_folder_path)
        return ts.init_table_schema_from_dict(schema_dict)

    @staticmethod
    def _load_table_schema_dict(schema_name: str, schema_folder_path: str) -&gt; Dict:
        try:
            with open(os.path.join(schema_folder_path, f&#34;{schema_name}.json&#34;), &#39;r&#39;) as schema_file:
                json_schema = json.loads(schema_file.read())
        except FileNotFoundError as file_err:
            raise FileNotFoundError(
                f&#34;Schema for corresponding schema name : {schema_name} is not found in the schema directory. &#34;
                f&#34;Make sure that &#39;{schema_name}&#39;.json &#34;
                f&#34;exists in the directory &#39;{schema_folder_path}&#39;&#34;) from file_err
        return json_schema

    @staticmethod
    def _validate_schema_folder_path(schema_folder_path: str):
        if not schema_folder_path or not os.path.isdir(schema_folder_path):
            raise FileNotFoundError(&#34;A schema folder path must be defined in order to create a out table definition &#34;
                                    &#34;from a schema. If a schema folder path is not defined, the schemas folder must be&#34;
                                    &#34; located in the &#39;src&#39; directory of a component : src/schemas&#34;)

    def _generate_table_metadata(self, table_schema: ts.TableSchema) -&gt; dao.TableMetadata:
        &#34;&#34;&#34;
            Generates a TableMetadata object for the table definition using a TableSchema object.

        &#34;&#34;&#34;
        table_metadata = dao.TableMetadata()
        if table_schema.description:
            table_metadata.add_table_description(table_schema.description)
        table_metadata.add_column_descriptions({field.name: field.description for field in table_schema.fields})
        table_metadata = self._add_field_data_types_to_table_metadata(table_schema, table_metadata)
        return table_metadata

    @staticmethod
    def _add_field_data_types_to_table_metadata(table_schema: ts.TableSchema,
                                                table_metadata: dao.TableMetadata) -&gt; dao.TableMetadata:
        &#34;&#34;&#34;
            Adds data types of all fields specified in a TableSchema object to a given TableMetadata object

        &#34;&#34;&#34;
        for field in table_schema.fields:
            if field.base_type:
                table_metadata.add_column_data_type(field.name,
                                                    data_type=field.base_type,
                                                    nullable=field.nullable,
                                                    length=field.length,
                                                    default=field.default)
        return table_metadata</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>abc.ABC</li>
<li><a title="keboola.component.interface.CommonInterface" href="interface.html#keboola.component.interface.CommonInterface">CommonInterface</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="keboola.component.base.ComponentBase.set_debug_mode"><code class="name flex">
<span>def <span class="ident">set_debug_mode</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Set the default logger to verbose mode.
Returns:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def set_debug_mode():
    &#34;&#34;&#34;
    Set the default logger to verbose mode.
    Returns:

    &#34;&#34;&#34;
    logging.getLogger().setLevel(logging.DEBUG)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="keboola.component.base.ComponentBase.create_out_table_definition_from_schema"><code class="name flex">
<span>def <span class="ident">create_out_table_definition_from_schema</span></span>(<span>self, table_schema: <a title="keboola.component.table_schema.TableSchema" href="table_schema.html#keboola.component.table_schema.TableSchema">TableSchema</a>, is_sliced: bool = False, destination: str = '', incremental: bool = None, enclosure: str = '"', delimiter: str = ',', delete_where: dict = None) ‑> <a title="keboola.component.dao.TableDefinition" href="dao.html#keboola.component.dao.TableDefinition">TableDefinition</a></span>
</code></dt>
<dd>
<div class="desc"><p>Creates an out table definition using a defined table schema.
This method uses the given table schema and generates metadata of the table. Along with the additional
key word arguments it creates an out table definition.</p>
<h2 id="args">Args</h2>
<dl>
<dt>table_schema : table of the schema for which a table definition will be created</dt>
<dt><strong><code>is_sliced</code></strong></dt>
<dd>True if the full_path points to a folder with sliced tables</dd>
<dt><strong><code>destination</code></strong></dt>
<dd>String name of the table in Storage.</dd>
<dt><strong><code>incremental</code></strong></dt>
<dd>Set to true to enable incremental loading</dd>
<dt><strong><code>enclosure</code></strong></dt>
<dd>str: CSV enclosure, by default "</dd>
<dt><strong><code>delimiter</code></strong></dt>
<dd>str: CSV delimiter, by default ,</dd>
<dt><strong><code>delete_where</code></strong></dt>
<dd>Dict with settings for deleting rows</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>TableDefinition object initialized with all table metadata defined in a schema</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def create_out_table_definition_from_schema(self, table_schema: ts.TableSchema, is_sliced: bool = False,
                                            destination: str = &#39;&#39;, incremental: bool = None,
                                            enclosure: str = &#39;&#34;&#39;, delimiter: str = &#39;,&#39;,
                                            delete_where: dict = None) -&gt; dao.TableDefinition:
    &#34;&#34;&#34;
        Creates an out table definition using a defined table schema.
        This method uses the given table schema and generates metadata of the table. Along with the additional
        key word arguments it creates an out table definition.

        Args:
            table_schema : table of the schema for which a table definition will be created
            is_sliced: True if the full_path points to a folder with sliced tables
            destination: String name of the table in Storage.
            incremental: Set to true to enable incremental loading
            enclosure: str: CSV enclosure, by default &#34;
            delimiter: str: CSV delimiter, by default ,
            delete_where: Dict with settings for deleting rows

        Returns:
            TableDefinition object initialized with all table metadata defined in a schema

    &#34;&#34;&#34;
    table_metadata = self._generate_table_metadata(table_schema)
    return self.create_out_table_definition(name=table_schema.csv_name,
                                            columns=table_schema.field_names,
                                            primary_key=table_schema.primary_keys,
                                            table_metadata=table_metadata,
                                            is_sliced=is_sliced,
                                            destination=destination,
                                            incremental=incremental,
                                            enclosure=enclosure,
                                            delimiter=delimiter,
                                            delete_where=delete_where)</code></pre>
</details>
</dd>
<dt id="keboola.component.base.ComponentBase.execute_action"><code class="name flex">
<span>def <span class="ident">execute_action</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Executes action defined in the configuration.
The default action is 'run'. See base._SYNC_ACTION_MAPPING</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def execute_action(self):
    &#34;&#34;&#34;
    Executes action defined in the configuration.
    The default action is &#39;run&#39;. See base._SYNC_ACTION_MAPPING
    &#34;&#34;&#34;
    action = self.configuration.action
    if not action:
        logging.warning(&#34;No action defined in the configuration, using the default run action.&#34;)
        action = &#39;run&#39;

    try:
        action = _SYNC_ACTION_MAPPING[action]
        action_method = getattr(self, action)
    except (AttributeError, KeyError) as e:
        raise AttributeError(f&#34;The defined action {action} is not implemented!&#34;) from e
    return action_method()</code></pre>
</details>
</dd>
<dt id="keboola.component.base.ComponentBase.get_table_schema_by_name"><code class="name flex">
<span>def <span class="ident">get_table_schema_by_name</span></span>(<span>self, schema_name: str, schema_folder_path: Optional[str] = None) ‑> <a title="keboola.component.table_schema.TableSchema" href="table_schema.html#keboola.component.table_schema.TableSchema">TableSchema</a></span>
</code></dt>
<dd>
<div class="desc"><p>The method finds a table schema JSON based on it's name in a defined schema_folder_path and generates
a TableSchema object.</p>
<h2 id="args">Args</h2>
<p>schema_name : name of the schema in the schema_folder_path. e.g. for schema in 'src/schemas/order.json'
schema_name is 'order'
schema_folder_path : directory path to the schema folder, by default the schema folder is set at
'src/schemas'</p>
<h2 id="returns">Returns</h2>
<p>TableSchema object initialized with all available table metadata</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_table_schema_by_name(self, schema_name: str,
                             schema_folder_path: Optional[str] = None) -&gt; ts.TableSchema:
    &#34;&#34;&#34;
        The method finds a table schema JSON based on it&#39;s name in a defined schema_folder_path and generates
        a TableSchema object.

        Args:
            schema_name : name of the schema in the schema_folder_path. e.g. for schema in &#39;src/schemas/order.json&#39;
                          schema_name is &#39;order&#39;
            schema_folder_path : directory path to the schema folder, by default the schema folder is set at
                                 &#39;src/schemas&#39;
        Returns:
            TableSchema object initialized with all available table metadata


    &#34;&#34;&#34;
    if not schema_folder_path:
        schema_folder_path = self.schema_folder_path
    self._validate_schema_folder_path(schema_folder_path)
    schema_dict = self._load_table_schema_dict(schema_name, schema_folder_path)
    return ts.init_table_schema_from_dict(schema_dict)</code></pre>
</details>
</dd>
<dt id="keboola.component.base.ComponentBase.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Main execution code of default run action.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@abstractmethod
def run(self):
    &#34;&#34;&#34;
    Main execution code of default run action.


    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="keboola.component.interface.CommonInterface" href="interface.html#keboola.component.interface.CommonInterface">CommonInterface</a></b></code>:
<ul class="hlist">
<li><code><a title="keboola.component.interface.CommonInterface.create_in_table_definition" href="interface.html#keboola.component.interface.CommonInterface.create_in_table_definition">create_in_table_definition</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.create_out_file_definition" href="interface.html#keboola.component.interface.CommonInterface.create_out_file_definition">create_out_file_definition</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.create_out_table_definition" href="interface.html#keboola.component.interface.CommonInterface.create_out_table_definition">create_out_table_definition</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.get_input_file_definitions_grouped_by_name" href="interface.html#keboola.component.interface.CommonInterface.get_input_file_definitions_grouped_by_name">get_input_file_definitions_grouped_by_name</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.get_input_file_definitions_grouped_by_tag_group" href="interface.html#keboola.component.interface.CommonInterface.get_input_file_definitions_grouped_by_tag_group">get_input_file_definitions_grouped_by_tag_group</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.get_input_files_definitions" href="interface.html#keboola.component.interface.CommonInterface.get_input_files_definitions">get_input_files_definitions</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.get_input_table_definition_by_name" href="interface.html#keboola.component.interface.CommonInterface.get_input_table_definition_by_name">get_input_table_definition_by_name</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.get_input_tables_definitions" href="interface.html#keboola.component.interface.CommonInterface.get_input_tables_definitions">get_input_tables_definitions</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.get_state_file" href="interface.html#keboola.component.interface.CommonInterface.get_state_file">get_state_file</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.is_legacy_queue" href="interface.html#keboola.component.interface.CommonInterface.is_legacy_queue">is_legacy_queue</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.set_default_logger" href="interface.html#keboola.component.interface.CommonInterface.set_default_logger">set_default_logger</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.set_gelf_logger" href="interface.html#keboola.component.interface.CommonInterface.set_gelf_logger">set_gelf_logger</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.validate_configuration_parameters" href="interface.html#keboola.component.interface.CommonInterface.validate_configuration_parameters">validate_configuration_parameters</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.validate_image_parameters" href="interface.html#keboola.component.interface.CommonInterface.validate_image_parameters">validate_image_parameters</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_filedef_manifest" href="interface.html#keboola.component.interface.CommonInterface.write_filedef_manifest">write_filedef_manifest</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_filedef_manifests" href="interface.html#keboola.component.interface.CommonInterface.write_filedef_manifests">write_filedef_manifests</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_manifest" href="interface.html#keboola.component.interface.CommonInterface.write_manifest">write_manifest</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_manifests" href="interface.html#keboola.component.interface.CommonInterface.write_manifests">write_manifests</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_state_file" href="interface.html#keboola.component.interface.CommonInterface.write_state_file">write_state_file</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_tabledef_manifest" href="interface.html#keboola.component.interface.CommonInterface.write_tabledef_manifest">write_tabledef_manifest</a></code></li>
<li><code><a title="keboola.component.interface.CommonInterface.write_tabledef_manifests" href="interface.html#keboola.component.interface.CommonInterface.write_tabledef_manifests">write_tabledef_manifests</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="keboola.component" href="index.html">keboola.component</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="keboola.component.base.sync_action" href="#keboola.component.base.sync_action">sync_action</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="keboola.component.base.ComponentBase" href="#keboola.component.base.ComponentBase">ComponentBase</a></code></h4>
<ul class="">
<li><code><a title="keboola.component.base.ComponentBase.create_out_table_definition_from_schema" href="#keboola.component.base.ComponentBase.create_out_table_definition_from_schema">create_out_table_definition_from_schema</a></code></li>
<li><code><a title="keboola.component.base.ComponentBase.execute_action" href="#keboola.component.base.ComponentBase.execute_action">execute_action</a></code></li>
<li><code><a title="keboola.component.base.ComponentBase.get_table_schema_by_name" href="#keboola.component.base.ComponentBase.get_table_schema_by_name">get_table_schema_by_name</a></code></li>
<li><code><a title="keboola.component.base.ComponentBase.run" href="#keboola.component.base.ComponentBase.run">run</a></code></li>
<li><code><a title="keboola.component.base.ComponentBase.set_debug_mode" href="#keboola.component.base.ComponentBase.set_debug_mode">set_debug_mode</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>